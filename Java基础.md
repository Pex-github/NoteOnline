高频点

java基础：
a. nio模型
b. java反射
c. java8特性
d. java中有哪些集合？各⾃自的数据结构？
e. 说说你⽤用过的设计模式
f. jdk以及spring中看过哪些设计模式



##### 修饰符的作用范围

​						private  default  protected 	public

同一个类中    可以		 可以		 可以	 	可以

同一个包的类中			 可以 	   可以 	 	可以

不同包的子类中				  			可以	    可以

不同包的类中				 								  可以

##### 面向对象和面向过程的区别

面向过程：性能高，但不宜维护和扩展

面向对象：易扩展维护，可以设计低耦合的系统。性能低

##### 关于 JVM JDK 和 JRE 最详细通俗的解答

java开发工具箱，java运行时环境，java虚拟机

##### 字符型常量和字符串常量的区别?

##### 几种数据类型

##### 基础数据类型和字符串的转换

基础数据类型包装类的ParseXXX(String)方法或valueOf(String)，即可返回相应的基本类型

基础数据类型与	空字符串“”   +	就可以获得对应的字符串

##### 运算笔记

3*0.1==0.3		结果false		浮点数不能完全精确的表示出来

a=a+b 与 a+=b 有什么区别		+=会进行隐式自动类型转换，a=a+b 则不会

short s1= 1; s1 = s1 + 1; 该段代码是否有错	有错误，改为s1 += 1

##### switch支持几种数据类型

byte，short，char，int，枚举，String

##### 特殊运算符

​	>>	右移（除）	<<	左移（乘）		&&	短路与		&按位与，逻辑与

##### 如何跳出多重嵌套循环

return：直接跳出当前方法，返回到调用语句处

break：在循环体内结束整个循环过程

continue：结束本次循环，执行下一次循环

可以给for加标记，可以在for条件判断里加flag

```java
ok:for(int i = 0;i < 10,i++){
    for(int j = 0;j < 10,j++){
        if(j==5){
            break ok;
        }
    }
}
boolean flag = true;
for(int i = 0;i < 10,i++){
    for(int j = 0;j < 10 && flag,j++){
        if(j==5){
            flag = false;
        }
    }
}
```



##### 重载和重写的区别

​	重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理【重载发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和访问 修饰符可以不同。】 重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法；重载发生在编译器，重写发生在运行期；重写遵循“两同两小一大”【方法名和形参相同】【子类返回值类型，抛出异常类 更小】【子类访问权限更大】（如果⽅法的返回类型是void和基本数据类型，则返回值重写时不可修改，若是引⽤类型， 重写时是可以返回该引⽤类型的⼦类的）

##### Java ⾯向对象编程三⼤特性: 封装 继承 多态

​	**封装**把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法，**继承**是使⽤已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能，

​	**多态**指同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果，必须在由程序运⾏期间才能决定

​	多态条件：有继承，有重写，有父类引用指向子类对象【Animal a = new Tiger();】

​	多态的三种实现方式：接口实现，继承父类重写方法，同一个类中进行方法的重载

​	虚拟机如何实现多态的：动态绑定技术，执行期间判断所引用对象的实际类型，根据实际 类型调用对应的方法



##### String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

​	String 类中使⽤ final 关键字修饰字符数组来保存字符串且不被继承（final类）

​	StringBuilder 与 StringBuffer 都继承⾃ AbstractStringBuilder 类，也是使⽤字符数组保存字符串，但是可变的

​	Stringbuffer对方法加了同步锁线程安全，stringbuilder不安全；stringbuilder比buffer拥有更好的性能

##### String s = new String("abc")创建了⼏个String Object？

1、2个，会创建String对象在常量池和堆中。 

2、String中的intern(),⾸先检查String pool是否有对应的字符串对象,如果有则返回，如果没有则在String pool中⽣成字符串， 并返回地址； 

3、String中字⾯值”abc"之间拼接是在String pool中产⽣,⽽字⾯值与变量拼接字符串或者new String(“")则是在堆中产⽣对象

##### 你对 String 对象的 intern()熟悉么?

intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在则现在常量池中创建，如果已经存在则直接返回。

一个汉字两个字节，16位



##### 自动装箱和拆箱

​	装箱：将基本类型用他们对应的引用类型包装起来，方法为ValueOf()

​	拆箱：将包装类装换为基本数据类型，例：方法为intValue()

​	包装类大都实现了常量池技术，Byte，Short，Integer，Long默认创建数值为[-128,127]的缓存数据，charater创建[0,127]浮点型没有实现该技术

##### 无参构造的作用

​	子类构造方法执行之前会调用父类构造方法，若父类没有无参构造，子类又没有指定父类构造方法，就会产生编译错误，父类无参构造器用来帮助子类做初始化工作

##### 类加载初始化，构造器和静态成员，普通成员执行的先后顺序

B继承A	A ab = newB();	

父类静态成员--》子类静态成员--》父类普通成员--》父类构造器-》子类普通成员--》子类构造器 

##### 接口和抽象类的区别

​	接口方法默认public且不能有实现，抽象方法可以有public，protected，default修饰符	

​	接口只能有static，final变量，抽象方法不一定

​	一个类可以实现多个接口，但只能继承一个抽象类

1、⼀个类声明可否既是abstract的,⼜是final的? 不能,这两个修式符⽭盾（abstract就是要被继承）

 2、抽象类不⼀定包含抽象⽅法 

3、有抽象⽅法,则⼀定是抽象类 

4、抽象类不能被实例化，⼀般⽤作基类使⽤；

​	抽象是对类的抽象，一种模板设计，接口是对行为的抽象，是一种行为的规范

![image-20210521162909231](C:\Users\PEX\AppData\Roaming\Typora\typora-user-images\image-20210521162909231.png)

##### 成员变量与局部变量的区别

​	成员变量属于类，局部变量属于代码块，前者可以被public，private，static，final修饰，后者不能被static修饰

​	局部变量：基本数据类型存储在栈内存，引用存放指向堆内存/常量池的地址

​	成员变量随对象的创建而存在，而局部变量随方法的调用消失

​	成员变量没有赋初值，会自动赋默认值，局部变量不会自动赋值

##### 静态方法和实例方法有何不同

​	调用静态方法不用进行实例化，静态方法访问本类成员时，只能访问静态成员变量和静态方法

##### 静态变量和实例变量的区别?

静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈

##### 静态嵌套类(Static Nested Class)和内部类（Inner Class） 的不同？

可以不依赖于外部类 实例被实例化。而通常的内部类需要在外部类实例化后才能实例化

如果要在静态方法中创建内部类对象，可以这样 做：new Outer().new Inner();

##### 抽象方法，静态方法，本地方法，synchronized是否可以同时修饰

抽象方法不可被实现，静态方法不可被重写，两者矛盾。本地方法由C语言实现，synchronized与实现细节有关

##### 内部类可以引用外部类的成员吗，限制

可以访问创建它的外部类对象的成员，包括私有成员。

##### ==和equals区别

​	前者判断地址是否相同，equals若没有覆盖等价于==，覆盖了则比较对象的内容是否相同，String类重写了equals方法，创建String类型对象时会在常量池中查找相同值得对象，有则赋值给当前引用，没有就在常量池中创建，StringBuffer和StringBuilder都是比较的地址

##### hashcode和equals

​	重写equals方法时，通常有必要重写hashcode方法，以便维护hashcode方法的常规约定：值相同的对象必须有先相同的hashcode

​	在一个hash结构的集合中添加元素时，集合会首先调用hashCode 方法，这样就可以直接定位它所存储的位置，唯一则存储，不唯一则再调用equals，结果相同则不再存储，结果不同则散列到其他位置。因为hashCode 效率更高（仅为一个int 值），减少了equals的次数，比较起来更快，若重写equals而不重写hashcode，hashSet或HashMap会存放相同的对象

**hashcode作用**：

1、hashCode的存在主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等，hashCode是 ⽤来在散列存储结构中确定对象的存储地址的；

 2、如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同； 

3、如果对象的equals⽅法被重写，那么对象的hashCode也尽量重写，并且产⽣hashCode使⽤的对象，⼀定要和equals⽅法中 使⽤的⼀致，否则就会违反上⾯提到的第2点；

 4、两个对象的hashCode相同，并不⼀定表示两个对象，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说 明这两个对象在散列存储结构中，它们存放在同⼀个桶⾥⾯。

##### hash冲突及解决办法

两个或两个以上的值hash计算的结果有相同的，造成的冲突 

解决办法：

​	**开放地址法**：插入【冲突就从冲突位置 遍历，知道 找到下一个空槽】。查找【查看散列值指向的槽，不匹配就从该位置遍历，直到遍历到一个空槽还没有就指示元素不存在】		缺点：导致相同hash元素在一起，其他hash槽被占用

​	**链地址法**：将同hash值的元素构成一个单链表，适用于多插入和删除的场景

​	**双/多重散列**：冲突时，继续hash函数计算，直到无冲突		缺点：计算时间增加

​	**建立公共溢出区**：溢出区存放发生冲突的记录



##### 一致性hash算法



##### 为什么Java中只有值传递

​	⼀个⽅法可以修改传递引⽤所对应的变量值，⽽不能修改传递值调⽤所对应的变量值。

​	⼀个⽅法不能修改⼀个基本数据类型的参数（即数值型或布尔型）。 ⼀个⽅法可以改变⼀个对象参数的状态。 ⼀个⽅法不能让对象参数引⽤⼀个新的对象。

##### 线程、程序、进程概念和关系

​	线程是⼀个⽐进程更⼩的执⾏单位，⼀个进程在其执⾏的过程中可以产⽣多 个线程。与进程不同的是同类的多个线程共享同⼀块内存空间和⼀组系统资源，程序是含有指令和数据的⽂件，进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位

​	线程和进程最⼤的不同在于基本上各进程是独⽴的

##### 线程有哪些状态

​	new runnable blocked waiting time_waiting terminated

​	程创建之后它将处于 NEW（新建） 状态，调⽤ start() ⽅法后开始运⾏，线程这时候处于 READY（可运⾏） 状态。可运⾏状态的线程获得了 cpu 时间⽚（timeslice）后就处于 RUNNING（运⾏） 状态。当线程执⾏ wait() ⽅法之后，线程进⼊ WAITING（等待）状态。进⼊等待状态的线程需要依靠 其他线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态 的基础上增加了超时限制，⽐如通过 sleeplong millis ⽅法或 waitlong millis ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状 态。当线程调⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。

##### final	finally	finalize

​	final变量不可改（编译阶段放在常量池）（引用不可 变，指向的内容可变），方法不可被重写，类不能被继承。final 类中的所有成员⽅法都会被隐式地 指定为 final ⽅法。

final两个重排序规则

1、在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
2、初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序

​	finally⽆论是否捕获或处理异常， finally 块⾥的语句都会被执⾏。当在 try 块或 catch 块中遇到 return 语句时， finally 语句块将在⽅法返回之前被执⾏。并且 finally 语句的返回值将会覆盖原始的返回值	，	以下情况不执行finally代码块：在 try 或 finally 块中⽤了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常 语句之后， finally 还是会被执⾏ 2. 程序所在的线程死亡。 3. 关闭 CPU。

​	finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

##### 异常

​	分为错误和异常，异常⼜包括运⾏时异常、⾮运⾏时异常

​	Exception分为受检查异常(必须处理) 和 不受检查异常(可以不处理)

​	除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受 检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException ...。

​	RuntimeException 及其⼦类都统称为⾮受检查异常，例 如： NullPointExecrption 、  ArrayIndexOutOfBoundsException （数组越界）、 ClassCastException （类型转换异常）、 ArithmeticException （算术异常），IllegalArgumentException （非法参数异常），IndexOutOfBoundsException （下标越界异常）。

​	Error：程序无法处理的错误，Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误 ( OutOfMemoryError )、类定义错误（ NoClassDefFoundError ）等



##### 什么是java序列化，如何实现序列化

1、原理：将对象写⼊流中,再从流中还原.ObjectOutPutStream 

2、对象中的成员对象也是可序列化的,但可通过transient关键字标示不序列化 3、通过序列化进⾏深拷⻉,从流中还原对象

4、序列化作⽤：对象保存(保存为⼀组字节，只保存对象的成员变量)；当使⽤-RMI(远程⽅法调⽤)，或者在⽹络中传递对象 时，都会使⽤对象序列化； 

5、serialVersionUID 主要是解决序列化后与再反序列化时有修改的不兼容问题.



##### 部分字段不进行序列化

​	对于不想进⾏序列化的变量，使⽤ transient 关键字修饰，作用是阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化 时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量

##### 键盘输入方式

​	方法一：创建个scanner对象再执行nextLine方法，记得关闭资源

​	方法二：创建个BufferedReader，添加一个inputStreamReader对象给前者的构造器，再执行readLine方法

##### IO流分类

​	输入/输出  字节流/字符流  节点流（对一个特定的地方或节点读写数据 ）/处理流（对一个已存在的流连接封装）

​	InputStream/Reader: 所有的输⼊流的基类，前者是字节输⼊流，后者是字符输⼊流。 	

​	OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

​	比如文件操作的FileInputStream/FileOutputStream和FileRead/FileWriter，其他相似的有管道操作Piped，数组操作ByteArray，CharArray，缓冲操作Buffered，基础数据类型操作Data

对象序列化操作Object，转换操作InputStreamReader、OutputStreamWriter，打印控制printStream和printWriter



##### NIO是什么，使用场景是什么

a. NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I/O，选择器，缓冲以及管道。 

b. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可 能是个很好的选择。(适⽤于**⼩数据多连接**) 

c. ⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响 应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。

NIO定义：

​	new IO，是一种非阻塞IO。采用了双向通道进行数据 传输，NIO三大核心部分

**Channel(通道)，Buffer(缓冲区), Selector(选择器)。**它基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区 写⼊到通道中。Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个 数据通道。 在通道上我们可以注册我们感兴趣的 事件：连接事件、读写事件

NIO原理：

	1. 由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发。 
 	2. 事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。 
 	3. 线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。



##### 有了字节流，为什么还要字符流

​	字符流是由虚拟机将字节转换的到的，过程较为耗时，编码容易出错，字符流可以方便对字符进行流操作

​	stream结尾都是字节流，reader和writer结尾都是字符流

​	在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。

只是读写文件，和文件内容无关的，一般选择字节流

##### 深拷贝和浅拷贝

​	基础数据类型：值传递，引用数据类型：(深拷贝：创建一个新对象，复制其内容)、(浅拷贝：复制了指向对象的指针，而不是对象本身)，接口Cloneable

##### 对象的四种引用

​	**强引用**：只要存在引用，就不会被回收

​	**软引用**：内存不足就回收

​	**弱引用**：发现就回收

​	**虚引用**：随时可以被回收，用来跟踪垃圾回收器的活动，必须和 引用队列联合使用



##### 反射机制

可以在运行时判断一个对象所属的类，构造一个类的对象，判断类具有 的成员变量和方法，调用1个对象的方法

4个关键的类：Class，Constructor，Field，Method。

getConstructor获得构造函数/getDeclardConstructor；getField/getFields/getDeclardFields获得类所声明的所有字段；getMethod/getMethods/getDeclardMethod获得类声明的所有⽅法，正 常⽅法是⼀个类创建对象，⽽反射是1个对象找到1个类。

##### 获取反射的3种方法

​	①通过new对象实现	.getClass

​	②通过路径实现	.forName

​	③通过类名实现	类名.class

```java
//方法1	建立对象
Student stu = new Student();
Class classObj = new stu.getClass();
//方法2	相对路径
Class ClassObj2 = Class.forName("bean.Student");
//方法3	类名
Class classObj3 =Student.class;
```

##### 聊聊反射机制

​	在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法

​	本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息

​	![反射解析 ](C:\Users\PEX\Desktop\image\反射解析 .png)

##### 创建对象的几种方式

采用new		通过放射		采用clone		通过序列化

##### Object中有哪些公共方法

equals()	clone()	getClass()	notify(),wait(),notifyAll()	toString()

##### 内存溢出是怎么回事

内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory

**内存溢出可能的原因**： 

i. 程序中存在死循环 

ii. 静态变量和静态⽅法太多了 

iii. 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的 

iv. ⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我 list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。 

v. 程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这 个程序就是太⼩了，需要⼿动增加内存。

**内存泄漏 memory leak**，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆 积后果很严重，⽆论多少内存,迟早会被占光。

##### 幂等性的处理方法

​	用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用

​	处理方式

​	⼀、查询操作是天然幂等 		⼆、唯⼀索引，防⽌新增脏数据		 三、token机制，防⽌⻚⾯重复提交 	

四、悲观锁 for update 		五、乐观锁（通过版本号/时间戳实现， 通过条件限制where avai_amount-#subAmount# >= 0） 	六、分布式锁 			七、状态机幂等（如果状态机已经处于下⼀个状态，这时候来了⼀个上⼀个状态的变更，理论上是不能够变更的，这样的话，保证 了有限状态机的幂等。）