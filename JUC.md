### 什么是线程和进程，及关系，区别，优缺点

**进程是程序的⼀次执⾏过程**，是系统运⾏程序的基本单位

**线程是进程中的实际执⾏单位**。⼀个进程在其执⾏的过程中可以产⽣多 个线程。

**⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的 元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈**

线程和进程最⼤的不同在于基本上各进程是独⽴ 的，⽽各线程则不⼀定，因为**同⼀进程中的线程极有可能会相互影响。线程执⾏开销⼩**，但不利 于资源的管理和保护；⽽进程正相反

### 为什么线程享有独立的程序计数器、虚拟机栈和本地方法栈

字节码解释器通过改变程序计数器来**依次读取指令**，**从⽽实现代码的流程控制**，像顺序执行，选择，循环等；多线程情况下可以用来**记录当前线程执行的位置**，从而切换线程保证线程恢复到正确执行位置

虚拟机栈：每个方法执行都会创建一个栈帧存储局部变量、操作数栈、常量池引用等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈 中⼊栈和出栈的过程。

本地 方法栈：虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。

两者都是保证线程中的局部变量不被别的线程访问到

堆和方法区是所有线程共享的资源，堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对 象 (所有对象都在这⾥分配内存)，⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 说说并发与并行的区别

并发： 同⼀时间段，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)； 并⾏： 单位时间内，多个任务同时执⾏。

### 为什么要使用多线程

多线 程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。加上现在多核CPU使得多个线程同时运行，减少线程上下文切换的开销

### 创建多线程的方式

继承 Thread 类 			优点 、代码简单 。 缺点 、该类无法集成别的类。

实现 Runnable 接口	优点 、继承其他类。 同一实现该接口的实例可以共享资源。 缺点 、代码复杂

 实现 Callable 接口		优点 、可以获得异步任务的返回值

 线程池方式					实现自动化装配，易于管理，循环利用资源。

### 多线程带来的问题有哪些

内存泄漏，上下文切换，死锁

### 说说线程的生命周期和状态

线程创建之后它将处于 NEW（新建） 状态，调⽤ start() ⽅法后开始运⾏， 线程这时候处于 READY（可运⾏） 状态。可运⾏状态的线程获得了 CPU 时间⽚（timeslice） 后就处于 RUNNING（运⾏）状态

当线程执⾏ wait() ⽅法之后，线程进⼊ WAITING（等待） 状态。进⼊等待状态的线程需要依靠 其他线程的通知才能够返回到运⾏状态，⽽ TIME_WAITING(超时等待) 状态相当于在等待状态 的基础上增加了超时限制，⽐如通过 sleep(ong millis) ⽅法或 wait(long millis) ⽅法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状 态。当线程调⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 BLOCKED（阻塞） 状态。线程在执⾏ Runnable 的 run() ⽅法之后将会进⼊到 TERMINATED（终⽌） 状态。

### 什么导致线程阻塞

![image-20210521171951094](C:\Users\PEX\AppData\Roaming\Typora\typora-user-images\image-20210521171951094.png)

### **一个线程出现了运行时异常了怎么办**

如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程 持有某个某个对象的监视器，那么这个对象监视器会被立即释放。

### 什么是上下文切换

多线程下，一般CPU核心个数小于线程数，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转 的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就 属于⼀次上下⽂切换。任务从保存到再加载的过程就是⼀次 上下⽂切换。

### 什么是线程死锁 ，如何避免

多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌

1.互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。 

2.请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。 

3.不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕 后才释放资源。 

4.循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。

避免方式：避免死锁，只要破坏上述 的四个条件就行，比如：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释 放它占有的资源。或者按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。 破坏循环等待条件。

### 说说sleep方法和wait方法区别和共同点

​	主要区别在于：sleep没有释放锁，而wait释放了锁

​	wait() 通常被⽤于线程间交互/通信， sleep() 通常被⽤于暂停执⾏。 wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或 者 notifyAll() ⽅法。 sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long timeout) 超时后线程会⾃动苏醒。

​	wait，notify只能在同步控制方法或同步代码块使用，sleep可以在任何地方使用

​	sleep必须捕获异常		wait，notify不需要捕获异常

​	sleep属于Thread类 的 方法		wait属于Object方法

### 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我 们不能直接调⽤ run() ⽅法

new ⼀个 Thread，线程进⼊了新建状态。调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就 绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动 执⾏ run() ⽅法的内容，这是真正的多线程⼯作。 但是，直接执⾏ run() ⽅法，会把 run() ⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线 程⼯作。

调⽤ start() ⽅法⽅可启动线程并使线程进⼊就绪状态，直接执⾏ run() ⽅法的话不会 以多线程的⽅式执⾏。

### 说一说自己对synchronized关键字的了解

synchronized 关键字解决的是多个线程之间访问资源的同步性， synchronized 关键字可以保证 被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏，早期版本，属于重量级锁，后来在java6之后官方从JVM层面上对synchronized ⼤优化，如自旋锁，偏向锁，轻量级锁等技术减少锁操作的开支

### 你是如何使用synchronized关键字的

修饰实例方法：作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁

修饰静态方法：对当前类加锁，作用于类的所有对象实例，访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访 问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。所以不会发生互斥现象

修饰代码块：指定加锁对象，可以是对象(this,objext)，也可以是类(类.class)

**构造⽅法可以使⽤ synchronized 关键字修饰么？**

构造⽅法不能使⽤ synchronized 关键字修饰，本身属于线程安全

```java
synchronized(this){
    ...//同步代码块
}
public synchronized void test2(){...}//方法锁
public class testClass{
    public void test03(){
        synchronized(testClass.class){...}//类锁
    }
    public static synchronized void test04(){}//类锁
}
```



### 讲一讲synchronized关键字 的底层原理

```
底层实现的本质是对对象监视器 monitor 的获取
-在同步语句块中，使⽤的是 monitorenter 和 monitorexit 指令，对应的位置分别是开头和结尾
执行到monitorenter指令，获取对象监视器 monitor 的持有权，锁的计数器加一
执行到monitorexit 指令，释放锁，锁的计数器减一
-修饰的⽅法，ACC_SYNCHRONIZED 标识，JVM通过标识来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤
```

synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位 置。当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权，锁的计数器为 0 则表示锁可以被获取，获取 后将锁计数器设为 1 也就是加 1。在执⾏ monitorexit 指令后，将锁计数器设为 0，表明锁被释放。Monitor 是基于 C++实现的，每个对 象中都内置了⼀个 ObjectMonitor 对象。wait/notify 等⽅法也依赖于 monitor 对象

synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调 ⽤。

两者的本质都是对对象监视器 monitor 的获取

### synchronized 和 ReentrantLock 的区别

本质区别：前者是关键字，后者是类

后者扩展性比前者强

（1）ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock 可以获取各种锁的信息 

（3）ReentrantLock 可以灵活地实现多路通知

二者的锁机制其实也是不一样的:

ReentrantLock 底层调用的是 Unsafe 的 park 方法加 锁，synchronized 操作的应该是对象头中 mark word。

### 为什么要弄一个CPU高速缓存

为了解决 CPU 处理速度和内存处理速度不对等的问 题，为了解决内存缓存不⼀致性问题可以通过制定缓存⼀致协议或者其他⼿段来解决

### 讲一讲JMM

实现了从主存中读取变量，线程把共享变量保存在本地 内存中，而不是直接在主存中读写，这就可能造成数据不一致的问题，volatile关键字指定了每次读取变量都要从主存中进行读取

### 说一说synchronized和volatile之间的区别

两者 互补，

volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定⽐ synchronized 关键字 要好。但是 volatile 关键字只能⽤于变量⽽ synchronized 关键字可以修饰⽅法以及代码 块。 volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两 者都能保证。

volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决 的是多个线程之间访问资源的同步性。



### ThreadLocal了解吗

```
他提供了线程安全的共享对象，以空间换时间的方式，为每个线程都提供了一份变量
```

主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成 存放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。

如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副 本。

ThreadLocalMap是ThreadLocal存放数据的地方，前者是后者的静态内部类，后者只是前者的封装，，调用set，get方法，实际上是调用的前者类对应的get和 set方法，后者 只是传递了数据，map数据结构中，key是当前thread对象，值为Object对象，

### ThreadLocal内存泄漏问题了解过吗？

 因为ThreadLocalMap中使用的key是弱引用，value是强引用，在gc时，若ThreadLocal没有被外部强引用，key就会被清理掉，value不会且永远不会gc。所以使用完ThreadLocal方法最好手动调用remove方法



### 实现Runnable和Callable接口的区别

Runnable接口不会返回结果或抛出检查异常，但Callable接口可以

Runnable的run方法纯粹执行方法体中的代码，callable的call方法返回的是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果

Callable+Future/FutureTask 却可以方便获取多线程运行的结果，可以在等待时间 太长没获取到需要的数据的情况下取消该线程的任务。

工具类Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。

### 实现Runnable接口和继承Thread类的区别

前者：适合多个线程处理同一个资源，避免java单继承限制

后者：可以将线程类抽象出来，多线程同步

### 执行execute方法和submit方法的区别

execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与 否； submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过 这个 Future 对象可以判断任务是否执⾏成功。

### 如何创建线程池

ThreadPoolExecutor创建，而不是Executors，因为阿里巴巴开发手册上推荐，不然容易创建大量线程或堆积大量请求，从而导致OOM

ThreadPoolExecutor构造器的主要参数

corePoolSize，最小同时运行的线程数，又叫核心线程数

maximumPoolSize，任务 队列容量满时的，最大同时运行线程数

workQueue，任务队列长度，超出核心线程数，会被放在队列中

ThreadPoolExecutor饱和策略，情况是 ：当超出最大同时运行线程数，且任务队列放满了

### 为什么要使用线程池

线程池提供了限制和管理资源，每个线程池会维护一些统计信息

降低资源消耗，提高响应速度，提高线程的可管理性

### 了解线程池的原理吗

提交任务，判断核心线程池是否满了（没满就创建线程），满了就判断等待队列是否满（不满就加入队列），满了就看线程池是否满了，线程池也满了就按照指定的策略处理，反之就创建线程

### 线程调度算法是什么

抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出 一个总的优先级并分配下一个时间片给某个线程执行

### Thread.sleep(0)的作用是什么

为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用 Thread.sleep(0) 手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作。

### 如果你提交任务时，线程池队列已满，这时会发生什么

如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队 列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存 放任务；如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue 中 ， ArrayBlockingQueue 满 了 ， 则 会 使 用 拒 绝 策 略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy。

### 介绍一下Atomic原子类

一般运用在多线程情况下，一个操作一旦开始就不会被其他的线程干扰，原子类就是具有原子操作特性的类，存放在java.util.concurrent.atomic。包含了基本类型，数组类型，引用类型的原子类，还包含对象属性修改类型的更新器

### AQS原理了解么

核心思想是，如果线程请求的是空闲资源，则线程被设定为有效工作线程，请求的资源被占用，则需要一套锁重新分配的机制，这个机制是用CLH队列锁实现的，简单来说就是暂时获取不到锁的线程就包装成一个节点加入到队列中

CLH队列是一个虚拟的双向队列，每个请求资源而阻塞的线程是这个队列中的一个节点，遵循着FIFO原则（先进先出），是公平锁

AQS定义了两种 资源共享方式：独占，共享

AQS底层使用设计模式：模板方法模式 ，如果需要自定义同步器需要完成以下条件

继承AQS类，并重写指定方法像对共享资源的获取和释放，然后调用aqs的模板方法

AQS拥有一些有趣的组件：

Semaphore(信号量)：允许多个线程同时访问某个资源；

CountDownLatch（倒计时器）一个同步工具类，用来协调多个线程之间同步

CyclicBarrier（循环栅栏）也是实现线程间的技术等待，但功能比上面的更强大 

### 使用过倒计时器（CountDownLatch）和CyclicBarrier 有什么区别

倒计时器就是 将指定数量的线程阻塞在某个地方，直至所有线程的任务都执行完毕

CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程 都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某 个点上之后，只是给某个数值-1 而已，该线程继续运行。 

CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务 

CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为 0 该 CountDownLatch 就 不可再用了

### 怎么检测一个线程是否持有对象监视器

Thread 类提供了一个 holdsLock(Object obj)方法，当且仅当对象 obj 的监视器被某条线程持有 的时候才会返回 true，注意这是一个 static 方法，这意味着”某条线程”指的是当前线程

### FutureTask是什么

FutureTask 表示一个异步运算的任务，里面可以传入一 个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经 完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。

## 锁

### 什么是自旋锁？

线程A要获得一把自旋锁，而锁又被其他线程占用，线程A就会在循环中自旋判断锁是否可用

作用：减少线程挂起和恢复的时间 ，提高执行效率

### Java中有哪几种锁

​	自旋锁: 自旋锁在 JDK1.6 之后就默认开启了。基于之前的观察，共享数据的锁定状 态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这 里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执 行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行 一个忙循环也就是自旋操作。在 jdk6 之后，引入了自适应的自旋锁，也就是等待的 时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。 

​	偏向锁: 在 JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原 语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一 个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏 向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性 能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个 不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考 虑是否使用偏向锁。 

​	轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级 锁”，所以在 Java SE1.6 里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状 态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着 偏向锁升级成轻量级锁后不能降级成偏向锁。

### 什么是乐观锁和悲观锁

乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作 为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的 重试逻辑。

悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的 锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。

### 如何在两个线程之间共享数据

通过在线程之间共享对象就可以了，然后通过 wait/notify/notifyAll、await/signal/signalAll 进 行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的。

### 如何正确的使用 wait()？使用 if 还是 while？

wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没 有满足，所以在处理前，循环检测条件是否满足会更好

![image-20210521173321547](C:\Users\PEX\AppData\Roaming\Typora\typora-user-images\image-20210521173321547.png)



### 生产者消费者模型 的作用

通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率

解耦，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约

如何实现一个生产者-消费者队列：

可以通过阻塞队列实现，也可以通过 wait-notify 来实现

### 什么是CAS

```
cas不通过jvm，直接调用本地方法，使用的cpu指令
他属于乐观锁技术，适合线程冲突少的情况。相反情况会降低性能

```



Compare and Swap，即比较-替换

有三个操作数：内存值 V、旧的预期值 A、要修改的值 B

当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true， 否则什么都不做并返回 false。

CAS 一定要 volatile 变量配合，这样才能保证每次拿到的 变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的 值 A



## 能说说volatile吗

volatile 主要有两方面的作用:1.避免指令重排 2.可见性保证

JVM 或者 JIT 为了获得更 好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与 其他语句重排序

某些情况下，volatile 还能提供原子性，volatile 类型的 double 和 long 的读写就是原子的

volatile 修饰符的另一个作用是提供内存屏障，当写一个 volatile 变量之前，Java 内存模型会 插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。能保证任何线程都能看到你写的值，同时，在写之 前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新 到缓存。

### ReentranReadWriteLock读写锁的使用？

![image-20210706234408391](C:\Users\PEX\AppData\Roaming\Typora\typora-user-images\image-20210706234408391.png)

### 可以kill一个线程吗

不可以，只有run方法或者线程main方法结束 ，又或者抛出异常，线程才会结束生命周期

### 分布式 锁

### 生产中使用多线程的经验

给线程命名 

最小化同步范围 

优先使用 volatile 

尽可能使用更高层次的并发工具而非 wait 和 notify()来实现线程通信,如 BlockingQueue,Semeaphore 

优先使用并发容器而非同步容器. 

考虑使用线程池