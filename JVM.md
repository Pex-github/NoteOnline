##### 类加载子系统

加载16进制的class文件

- 加载
  - 获取类的二进制字节流
  - 转换到方法区的运行时数据
  - 在方法区建立一个访问该类的入口
- 链接
  - 验证：确保二进制字节流符合要求
  - 准备：为类变量赋零值，final变量显式赋值
  - 解析：将常量池内的符号引用转换为直接引用
- 初始化：执行类构造器方法clinit（）包含了类变量赋值动作和静态代码块

![1846149-20200401150612585-1361740692](C:\Users\PEX\AppData\Local\Temp\1846149-20200401150612585-1361740692.png)

优点：避免类的重复加载，保护程序安全，避免核心api被随意篡改（比如写了个String类，里面包含了恶意代码，向上委托到引导类加载器，然后加载器发现核心API中发现这个名字的类，那他会直接加载核心API的类，所以遇上双亲委派机制就行不通，而且自定义java.lang包，是需要权限，他会阻止使用该包名）



##### 介绍下Java内存区域（运行时 数据区域）

1.8之前，线程共享的有堆，方法区（其中包含运行时常量池），线程私有的有虚拟机栈，本地方法栈，程序计数器

##### 程序计数器

辅助字节码解释器获取下一条指令，同时也是为了在多线程切换后恢复到正确的执行位置，每个线程都独有一个程序计数器，互不影响，独立存储

##### 虚拟机栈

生命周期和线程相同，每次方法调用的数据都是通过栈传递的，虚拟机栈是由一个个栈帧组成，每个栈帧都包含：局部变量表，操作数栈，动态链接，方法出口信息，局部变量表主要存放了编译期可知的各种数据类型，对象引⽤类型。每次方法调用都会 有一个对应的栈帧压入java栈，每次调用结束，都会有一个栈帧被弹出

##### 本地方法栈

虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节 码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务

##### 堆

此内存区域的唯⼀⽬的就是存放对象实例，⼏乎所有的对象实例以及数组都在这⾥分配内存，但随着 JIT编译期的发展和逃逸分析技术逐渐成熟，有些未逃逸出去的对象，可以直接在栈上分配内存

实例变量

##### 方法区 

1.8之前叫永久代，1.8之后叫元空间，两者并不相同，元空间使用的是 直接内存，受本机可用内存限制，也可以自定义大小。元空间存放的是类的元数据

类信息，运行时常量池，域信息，方法信息，JIT代码缓存



##### 简述JVM内存分配

基本数据类型的变量和对象的引用都是在栈分配的。 

堆内存用来存放由 new 创建的对象和数组。

 类变量（static 修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆 中的内存地址存放在栈中。 

实例变量：当你使用 java 关键字 new 的时候，系统在堆中开辟并不一定是连续的空 间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征 这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被 GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。 

局部变量: 由声明在某方法，或某代码段里（比如 for 循环），执行到它的时候在栈 中开辟内存，当局部变量一但脱离作用域，内存立即释放





##### 说一说Java对象的创建过程

- 类加载 检查，检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必 须先执⾏相应的类加载过程。


- 分配内存，虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成 后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分配 ⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配⽅式由 Java 堆是否规整决定，⽽ Java 堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。


- 创建对象必须线程安全，虚拟机采⽤两种⽅式来保 证线程安全： CAS+失败重试： CAS 是乐观锁的⼀种实现⽅式。所谓乐观锁就是，每次不加锁⽽是假设 没有冲突⽽去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。 TLAB： 为每⼀个线程预先在 Eden 区分配⼀块⼉内存，JVM 在给线程中的对象分配内存 时，⾸先在 TLAB 分配，当对象⼤于 TLAB 中的剩余内存或 TLAB 的内存已⽤尽时，再采⽤ 上述的 CAS 进⾏内存分配


- 初始化零值，为实例变量赋予默认值，


- 设置对象头，虚拟机要对对象进行必要的设置，将类的元数据信息引用，对象的哈希吗，对象的GC分代年龄等信息存放在对象头 中


- 执行init方法


##### 对象的访问定位 有哪些

​	Java程序通过栈上的 reference 数据来操作堆上的具体对象，主流的访问⽅式有①使⽤句柄和②直接指针

​	句柄：会创建一个句柄池，引用存储 的就是对象的句柄地址，句柄包含对象实例数据与类型数据各自的具体信息

​	直接指针：引用中存储 的就是对象的地址

​	前者的好处就是，对象移动只用改变句柄中 的指针，后者 的好处就是速度快，节省了一次 指针定位的时间开销

##### 简单聊聊JVM内存分配与回收

​	Java堆是 垃圾回收的主要区域，现在收集器采用 的都是分代垃圾收集算法，将堆分为新生代，老年代，细致点 可以分为eden区，survivorTo/From空间，old区。目的是更好回收内存垃圾，更快分配内存，每次垃圾回收，对象若存活则会进入s0/s1。并且年龄加一 。加到15时，进入老年代。每次GC后，eden区和from区都会 被清空，存活的转移到To区或老年区

##### 堆内存中对象的分配的基本策略

​	对象优先分配到eden区，eden区存不下，虚拟机发起MinorGC，按照分配担保机制，将新生代对象提前转移到老年代。还存不下就会发生FullGC

​	大对象进入老年代，避免由于分配担保机制带来的复制降低效率。

​	长期存活的进入老年代

​	动态对象年龄判断

##### GC的分类

部分收集：

​	新生代收集：MinorGC/YoungGC

​	老年代收集：MajorGC/OldGC。有时候Major代指整堆收集

​	混合收集：MixedGC：整个新生代和部分老年代

整堆收集：FullGC（收集整个堆和方法区）

##### 如何判断对象是否死亡

​	引用计数法：给对象添加一个引用计数器，引用加一，失效减一。0则不再被使用

​	可达性算法分析：以GCRoots的对象起点，向下搜索，节点走过的路径叫做引用链。当一个对象到GCroots没有任何引用链相连的话，则对象死亡

##### 介绍下强引用，软引用，弱引用，虚引用

​	**强**：对象具有强引用，则不被回收，内存不足则抛出OOM

​	**软**：内存空间不足 了就回收软引用对象

​	**弱**：垃圾回收器扫描到了弱引用对象就回收，生命周期更短

​	**虚**引用，形同虚设，和没用引用一样，随时可能被回收，主要用来跟踪对象被垃圾回收的活动

​	虚引用与软和弱的区别是，必须和 引用队列联合使用。一弱和虚都很少使用，软用 的较多。因为软引用可以加速加速JVM对垃圾内存的回收速度，可以维护系统的运⾏安全，防⽌内存溢出 （OutOfMemory）等问题的产⽣

##### 如何判断一个常量 是废弃常量

​	运行时常量池主要回收的废弃常量，如果没有String对象指向一个常量"abc"，那么"abc"就是废弃常量

##### 如何判断一个类是无用类

满足3个条件：

​	该类的所有实例被回收，不存在实例

​	加载该类的ClassLoader被 回收

​	该类没有被任何通过反射访问该类的方法

##### 垃圾收集有哪些算法

​	标记清除算法：标记所有不回收的对象，之后统一回收。效率低，内存碎片

​	复制算法：内存分为两份，存活的复制 到另一半去，然后清理

​	标记整理算法：标记存活，移动向一端，清理掉边界以外的内存

​	分代收集算法：存活周期的不同将内存分为几块。在新生代选择复制算法，在老年代选择标记整理或清除算法。这样可以提升GC效率

##### 常见的垃圾回收器有哪些

​	serial收集器：单线程收集器，历史悠久，必须 暂停工作线程才能收集（新生代采用 复制算法，老年代采用 标记整理算法）

​	ParNew收集器 ：前者的多线程版本，新生老年都一样

​	Parallel Scavenge收集器：关注吞吐量，可以高效利用CPU。吞吐量就是 CPU 中⽤于运⾏⽤户代码 的时间与 CPU 总消耗时间的⽐值。⼿⼯优化存在困难的时候，使⽤ Parallel Scavenge 收集器配合⾃适应调节策略是个不错的选择。同时 是JDK1,8的 默认收集器

​	serial Old收集器 ：单线程，老年代收集器

​	Parallel Old收集器：Parallel Scavenge老年代版本。多线程和标记整理算法

​	CMS收集器：注重最短停顿时间，提高用户体验。第一个并发收集器，实现了用户线程和垃圾收集线程同时工作。过程分为：初始标记（暂停用户，标记与root可达对象），并发标记（标记运行时可达对象），重新标记（暂停用户，修正标记），并发清除（开启用户，未标记清除）缺点就是对CPU资源敏感，无法处理浮动垃圾，标记清理产生的内存碎片

​	G1收集器：面向服务器，同时满足短停顿，高吞吐量。分代收集，并发工作，标记整理，可预测停顿，指定停顿模型。过程分为：初始标记，并发标记，最终标记，筛选回收。维护 了 一个 优先列表，优先回收价值最大的垃圾

##### 类加载机制

​	就是虚拟机把类的数据从class文件加载到内存，并对数据进行校检，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程

![类加载](C:\Users\PEX\Desktop\image\类加载.png)

第一阶段：加载==》类加载器

​	类加载器根据一个类的全限定名读取类的二进制字节流到JVM中，然后生成对应的java.lang.Class对象实例

（1）启动类加载器（Bootstrap ClassLoader）：负责加载 在<JAVA_HOME>\lib目录 和 被-Xbootclasspath参数所指定的路径中的类库 

（2）扩展类加载器（Extension ClassLoader）：负责加载 <JAVA_HOME>\lib\ext目录 和 被java.ext.dirs系统变量所指定的路径中的所有类库

（3）应用程序类加载器（Application ClassLoader）：负责加载用户类路径classPath所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

（4）自定义加载器（CustomClassLoader）：属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。
	注意：类的唯一性是由他的类加载和全限定名共同 决定 的。比较类相同的前提是有相同的类加载，类加载器不同，必定不相同。JVM规定类只能有一个类加载器对类进行加载。

​	保证只有一个类加载器的实现：双亲委派模型

​	当类加载器收到类加载的请求，他不会自己去加载，而是把这个请求给父加载器，最终请求传到最顶层的启动器类，然后父加载器无法完成加载请求，交给子加载器去加载

##### 调用System.gc()会发生什么

通知GC开始 工作，具体的开始时间不确定

##### 你了解守护线程吗？它和非守护线程有什么区别

程序运行完毕，jvm 会等待非守护线程完成后关闭，但是 jvm 不会等待守护线程。守护线程 最典型的例子就是 GC 线程。



