1. 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。
2. 事务的特性：原子性（事务是不可分割的）一致性（数据库从一个一致性变为另一个一致性状态）隔离性（事务的执行不被其他事务干扰）持续性（事务提交后，对数据库的改变是持久的）
3. 数据库日志记录包含了事务标识，操作类型，操作对象，更新前的旧值，更新后的新值。注意：登记日志时，必须先写日志文件再数据库修改
4. 事务故障的恢复步骤：反向扫描文件日志，查找更新操作；对更新操作执行逆操作；继续反向扫描日志，继续同样处理，直到读到事务的开始标记
5. 数据库不一致原因：事务未完成但已写入（撤销恢复），已提交但留在缓存区未写入（重做恢复）；如有检查点，建立重做队列和撤销队列。检查时间点前无需重做，检查点到系统故障时间点之间重做，系统故障时间点之后撤销
6. mysql优点：支持多语言，跨平台，开源，多线程，并发访问
7. 数据类型：数值类型，字符串类型，时间和日期类型
8. 逻辑架构：连接层，服务器，存储引擎层，数据存储层，
9. 主键应是一个没有任何实际意义的字段，一般主键作为其他表的外键
10. 唯一键一般为有实际业务含义的，不重复，不是主键的一个字段
11. 约束：主键约束，外键约束，check()约束【值范围】，default约束【默认值】，unique约束【唯一可为空】，not null约束【必赋值】
12. B+树所有有效的索引关键字都存储在叶节点中，查询速度稳定，遍历更快，树的层级更少，有排序功能，innoDB引擎使用
13. Hash索引在等值查询有绝对优势，但有大量重复建值情况下效率低下，没办法利用索引完成排序，不支持多列联合索引的最左匹配原则
14. 聚簇索引一般是主键；没有主键，就是第一个唯一键；没有唯一键，就是隐藏ID，每张表都会有一个聚簇索引。聚簇索引是一级索引
15. 索引的优点：减少服务器扫描的数据量，减少排序和临时表，将随机IO变为顺序IO
16. 性能优化，不等于提升QPS，一般需要统计排序任务花费时间，将重要任务排前面
17. 查询优化：①SQL语句以及索引优化② 数据库表结构的优化③ 系统配置的优化④ 硬件的优化，优化效率递减排序，第一个影响最大
18. 



------

b 树和hash 索引应用场合区别

主键索引和普通索引的区别

聚簇索引在底层怎么实现的，数据和关键字是怎么存的

复合索引复合索引要把那个字段放最前，为什么

为啥MySQL 索引要用B+树而MongoDB 用B 树？

##### 主键和唯一索引的区别？

​    在创建主键的同时会生成对应的唯一索引，主键在保证数据唯一性的同时不允许为     空，而唯一可以有一个为空数据项，一个表中只能有一个主键，但是一个主键可以     有多个字段，一个表中可以有多个唯一索引。

##### MySQL 中有哪几种锁

1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最 高，并发度最低。 

2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最 低，并发度也最高。 

3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表 锁和行锁之间，并发度一般。

##### MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐 级之间的区别

SQL 标准定义的四个隔离级别为： 

1、read uncommited ：读到未提交数据 

2、read committed：脏读，不可重复读 

3、repeatable read：可重读 

4、serializable ：串行事物

### 事务

##### 定义

(1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 

(2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 

(3)事务用来管理 insert,update,delete 语句。

原理：mysql每执行一条语句记录一条日志，先记日志，再操作数据库。事务操作失败，检查日志回滚

##### 特征

ACID

原子性（要么都做，要么都不做）

一致性（多节点操作数据，数据保持一致）比如A向B转账，A扣钱了，B的余额不能没增加

隔离性（保证多事务并发执行，数据要保持一致）

持久性（事务完成后，不会因为系统故障而数据丢失）



![image-20210715185124780](C:\Users\PEX\AppData\Roaming\Typora\typora-user-images\image-20210715185124780.png)

##### 隔离级别

**读未提交**

​	男人到银行存钱，存1000，然后女人查看账户，发现多1000，不错，到账

​	然后男人，回滚。私吞了1000块

​	这时，女人读取的数据叫	脏读

**读已提交**

​	男人去消费，查账有余额

​	老婆转账，男人发现余额不对，此时的错误是不可重复读

​	A事务在本次事务中，对自己操作过的数据，进行了多次读取发现数据不一致，不可重复读。 简单点说就是不能让我好好的重复读，一个事务里读出来的数据都不一样，让不让人干活了。 针对的语句update和delete，会导致不可重复读

**可重复读**【innoDB默认级别】

​	楠哥的老婆在银行部门工作，她时常通过银行内部系统查看楠哥的账户信息。有一天，她正在查询到楠 哥账户信息时发现楠哥只有一个账户，心想这家伙应该没有私房钱。此时楠哥在另外一家分行右开了一 个账户，准备存私房钱。一次同时楠哥老婆点击了打印，结果打印出的楠哥账户居然多了一个，真实奇 怪

​	原理：事务开启后，将历史数据存一份快照，其他事务增加与删除的数据，对于当前事务来说是不可见 的。

​	出现的错误：幻读

**串行化**

​	事务A和事务B，事务A在操作数据库时，事务B只能排队等待 

​	这种隔离级别很少使用，吞吐量太低，用户体验差 

​	这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不 并发。 

​	别的地方一用这个数据就不能修改删除，直到别的地方提交

老婆在操作账户，男人只能等着，WTF

##### 锁机制

行锁的特点就是开销大、加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度高

表锁 的特点就是开销小、加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率高，并发度相对 低。

 1、对于InnoDB表，在绝大部分情况下都应该使用**行级锁**，因为事务和行锁往往是我们之所以选择 InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。 

第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事 务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提 高该事务的执行速度。 

第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可 以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

锁的类型

**读锁**【共享锁】，可以多个事务读，但只能一个事务写

通过select.... lock in share mode被读取的行记录或行记录的范围上加一个读锁

select * from teacher where id = 1 lock in share mode;

**写锁**【排他锁】	就是只能有一个事务操作这个数据，别的事务都不行

若是别人还能读，就回答mysql实现了MVCC模型

**MDL锁**	锁表设计，不准别人执行DDL语句，也就是不准别人添加新的字段

**意向锁**	意向锁和MDL锁都是为了防止在事务进行中，执行DDL语句导致数据不一致

0

------

**乐观锁**

基于数据版本记录机制实现，一般是给数据库表增加一个"version"字段。读取数据时，将 此版本号一同读出，之后更新时，对此版本号加一。此时将提交数据的版本数据与数据库表对应记录的 当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过 期数据。

**悲观锁**

依靠数据库提供的锁机制实现。MySQL中的共享锁和排它锁都是悲观锁。数据库的增删改操作默 认都会加排他锁，

**死锁**

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，就是所谓的 锁资源请求产生了回路现象，即死循环。

如何避免：约定使用相同顺序访问表；尽量采用小事务，避免使用大事务；同一个事务中尽量做到一次锁定所需要的所有资源； 对于非常容易发生死锁的业务，可以尝试使用升级锁的力度

-------

##### redo log

InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。数据在内存中被修改，与磁盘中相比就存在 了差异，我们称这种有差异的数据为脏页。引擎不会马上处理这些脏页，因为这会产生海量的io操作，影响innoDB的性能

产生脏页后，如果在这期间DB 出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了

redo log就是存储了数据被修改后的值。当我们 提交一个事务时，InnoDB会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。

我们着重看看redo log是怎么一步步写入磁盘的。

##### 解释⼀下什么是池化设计思想。什么是数据库连接池?为什么 需要数据库连接池?

数据库连接本质就是⼀个 socket 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类 的 所以占⽤了⼀些内存。**我们可以把数据库连接池是看做是维护的数据库连接的缓存**，以便将来 需要对数据库的请求时可以重⽤这些连接。为每个⽤户打开和维护数据库连接，尤其是对动态数 据库驱动的⽹站应⽤程序的请求，既昂贵⼜浪费资源。**在连接池中，创建连接后，将其放置在池 中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其 添加到池中。 连接池还减少了⽤户必须等待建⽴与数据库的连接的时间。**

